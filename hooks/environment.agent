#!/usr/bin/env bash

# Use more compatible shell options for Windows Git Bash
set -euo pipefail
# Note: pipefail can cause issues in Git Bash on Windows, but we'll keep it for error detection

# Detect Windows early for compatibility adjustments
IS_WINDOWS=false
if [[ "$(uname -s 2>/dev/null || echo unknown)" == MINGW* ]] || [[ -n "${WINDIR:-}" ]]; then
    IS_WINDOWS=true
    echo "Windows environment detected"
fi

## A foundational concept for the usage of this hook is that we can deny access to secrets
## (such as the agent private key or the build token file) by deleting or unmounting the
## `/secrets` folder.  This agent should always be running within some kind of sandbox,
## whether that be a Docker container or whatever.  When the job is finished, the buildkite
## agent should exit, causing the docker container to restart and restore the deleted files.
## This gives us the capability to deny access to these files to later steps within the
## current buildkite job.
# Detect Windows and set appropriate default secrets path
if [[ "$IS_WINDOWS" == "true" ]]; then
    SECRETS_MOUNT_POINT="${BUILDKITE_PLUGIN_CRYPTIC_SECRETS_MOUNT_POINT:-/c/buildkite-agent/secrets}"
else
    SECRETS_MOUNT_POINT="${BUILDKITE_PLUGIN_CRYPTIC_SECRETS_MOUNT_POINT:-/secrets}"
fi

## The secrets that must be contained within:
##    - `agent.{key,pub}`: An RSA private/public keypair (typically generated via the
##       script `bin/create_agent_keypair`).  See the top-level `README.md` for more.
##    - `buildkite-api-token`: A buildkite API token (with `read_builds` permission).

## The helper programs that must be available on the worker:
##    - openssl v3 (from Homebrew on macOS)
##    - shred (Linux only)
##    - shyaml
##    - jq

# Helper function
function die() {
    echo "ERROR: ${1}" >&2
    buildkite-agent annotate --style=error "${1}"
    exit 1
}

function base64dec() {
    tr -d '\n' | openssl base64 -d -A
}

function base64enc() {
    openssl base64 -e -A
}

# Windows-compatible mktemp function
function safe_mktemp() {
    if command -v mktemp >/dev/null 2>&1; then
        mktemp
    else
        # Fallback for systems without mktemp (like some Windows environments)
        local temp_dir="${TMPDIR:-${TMP:-${TEMP:-/tmp}}}"
        local temp_file="${temp_dir}/tmp.$$.$RANDOM"
        touch "$temp_file" && echo "$temp_file"
    fi
}

if [[ -n "$(which shred 2>/dev/null)" ]]; then
    function secure_delete() {
        shred -u "$*"
    }
elif [[ "$(uname)" == "Darwin" ]] || [[ "$(uname)" == *BSD ]]; then
    function secure_delete() {
        rm -fP "$*"
    }
else
    # Suboptimal, but what you gonna do?
    function secure_delete() {
        rm -f "$*"
    }
fi

function cleanup_secrets() {
    ## Cleanup: Deny access to secrets to future pipeline steps by either unmounting `/secrets`
    #  or just deleting the files inside, if that doesn't work.  If neither work, we abort the build.
    
    # On Windows, umount is not available, so skip that attempt
    if [[ "$IS_WINDOWS" == "true" ]]; then
        echo "Windows detected, skipping umount attempt"
        if ! rm -rf "${SECRETS_MOUNT_POINT}"; then
            die "Unable to delete secrets at '${SECRETS_MOUNT_POINT}'!  Aborting build!"
        fi
    else
        # Unix/Linux: try umount first, then rm
        if ! umount "${SECRETS_MOUNT_POINT}" 2>/dev/null; then
            if ! rm -rf "${SECRETS_MOUNT_POINT}"; then
                die "Unable to unmount secrets at '${SECRETS_MOUNT_POINT}'!  Aborting build!"
            fi
        fi
    fi

    # don't pollute the global namespace
    unset SECRETS_MOUNT_POINT BUILDKITE_TOKEN_PATH BUILDKITE_TOKEN AGENT_PRIVATE_KEY_PATH ADHOC_PAIR
}

# No matter how we exit, make sure we cleanup our secrets
trap "cleanup_secrets" EXIT

# Set this to wherever your private key lives
AGENT_PRIVATE_KEY_PATH="${SECRETS_MOUNT_POINT}/agent.key"
AGENT_PUBLIC_KEY_PATH="${SECRETS_MOUNT_POINT}/agent.pub"
if [[ ! -f "${AGENT_PRIVATE_KEY_PATH}" ]]; then
    echo "Unable to open agent private key path '${AGENT_PRIVATE_KEY_PATH}'!  Make sure your agent has this file deployed within it!"
    echo "NOTE: This is a known bug where this agent is old, caused by the agent not restarting after a previous job."
    echo "see https://github.com/JuliaCI/sandboxed-buildkite-agent/issues/42"
    echo "Showing debug information..."
    powershell.exe -Command "& {
        \$providers = @(
            @{LogName='Application'; ProviderName='nssm'},
            @{LogName='System'; ProviderName='User32'}
        );
        foreach (\$provider in \$providers) {
            Write-Host \"\`n   ProviderName: \$(\$provider.ProviderName)\`n\";
            Get-WinEvent -LogName \$(\$provider.LogName) -FilterXPath \"*[System[Provider[@Name='\$(\$provider.ProviderName)']]]\" -MaxEvents 50 |
            Sort-Object TimeCreated |
            Select-Object TimeCreated, Id, LevelDisplayName, Message |
            Format-Table -Wrap
        }
        }"
    exit 1
else
    if ! openssl rsa -inform PEM -in "${AGENT_PRIVATE_KEY_PATH}" -noout 2>/dev/null; then
        die "Secret private key path '${AGENT_PRIVATE_KEY_PATH}' is not a valid private RSA key!"
    fi
fi
if [[ ! -f "${AGENT_PUBLIC_KEY_PATH}" ]]; then
    die "Unable to open agent public key path '${AGENT_PUBLIC_KEY_PATH}'!  Make sure your agent has this file deployed within it!"
else
    if ! openssl rsa -inform PEM -pubin -in "${AGENT_PUBLIC_KEY_PATH}" -noout 2>/dev/null; then
        die "Secret public key path '${AGENT_PUBLIC_KEY_PATH}' is not a valid public RSA key!"
    fi
fi

# Create a buildkite token with `read_builds` permissions, paste it in here.
BUILDKITE_TOKEN_PATH="${SECRETS_MOUNT_POINT}/buildkite-api-token"
if [[ ! -f "${BUILDKITE_TOKEN_PATH}" ]]; then
    die "Unable to open buildkite token path '${BUILDKITE_TOKEN_PATH}'!  Make sure your agent has this file deployed within it! "
fi
BUILDKITE_TOKEN="$(cat "${BUILDKITE_TOKEN_PATH}")"
if ! [[ "${BUILDKITE_TOKEN}" =~ ^[[:xdigit:]]{40}$ ]]; then
    die "Buildkite token stored at '${BUILDKITE_TOKEN_PATH}' is not a 40-length hexadecimal hash!"
fi

function is_uuid() {
    [[ "${1}" =~ ^[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12}$ ]]
}

# Helper function to get the first job ID from the currently-running build
function get_initial_job_id() {
    local TOKEN_HEADER="Authorization: Bearer ${BUILDKITE_TOKEN}"
    local URL="https://api.buildkite.com/v2/organizations/${BUILDKITE_ORGANIZATION_SLUG}/pipelines/${BUILDKITE_PIPELINE_SLUG}/builds/${BUILDKITE_BUILD_NUMBER}"

    local CURL_OUTPUT=""
    local CURL_UUID=""
    # Reduce retry attempts to lower memory pressure
    for idx in 1 2; do
        # Use more memory-efficient curl options
        CURL_OUTPUT="$(curl -sfL --max-time 30 --connect-timeout 10 -H "${TOKEN_HEADER}" "${URL}" 2>/dev/null || true)"
        if [[ -n "${CURL_OUTPUT}" ]]; then
            CURL_UUID="$(echo "${CURL_OUTPUT}" | jq -r '.jobs[0].id // empty' 2>/dev/null || true)"
            if is_uuid "${CURL_UUID}"; then
                echo -n "${CURL_UUID}"
                return
            fi
        fi
        echo "ERROR: Initial job ID retrieval failed (attempt ${idx}/2)" >&2
        # Clear variables to free memory
        CURL_OUTPUT=""
        CURL_UUID=""
        sleep 1
    done
    die "Unable to retrieve valid initial job ID after 2 attempts"
}

# Get initial job ID with memory-efficient handling
BUILDKITE_INITIAL_JOB_ID=""
BUILDKITE_INITIAL_JOB_ID="$(get_initial_job_id)" || die "Failed to get initial job ID"
export BUILDKITE_INITIAL_JOB_ID
function set_cryptic_privileged() {
    # The first thing we do is export a base64-encoded form of the keys for later consumption by the cryptic plugin
    echo "Privileged build detected; unlocking private key"
    
    # Process keys one at a time to reduce memory pressure
    local temp_key_data
    temp_key_data="$(base64enc < "${AGENT_PRIVATE_KEY_PATH}")" || die "Failed to encode private key"
    export BUILDKITE_PLUGIN_CRYPTIC_BASE64_AGENT_PRIVATE_KEY_SECRET="${temp_key_data}"
    unset temp_key_data
    
    temp_key_data="$(base64enc < "${AGENT_PUBLIC_KEY_PATH}")" || die "Failed to encode public key"
    export BUILDKITE_PLUGIN_CRYPTIC_BASE64_AGENT_PUBLIC_KEY_SECRET="${temp_key_data}"
    unset temp_key_data
    
    export BUILDKITE_PLUGIN_CRYPTIC_PRIVILEGED=true

    # The next thing we do is search for `CRYPTIC_ADHOC_SECRET_*` variables and decrypt them.
    # These should only be used for things like SSH keys, which need to be decrypted before we
    # even have a chance to check out the repository.
    # Process secrets one at a time to minimize memory usage
    local adhoc_vars
    adhoc_vars="$(set | grep -E "^CRYPTIC_ADHOC_SECRET_[^ ]+" | cut -d"=" -f 1 || true)"
    
    if [[ -n "${adhoc_vars}" ]]; then
        while IFS= read -r LONG_ADHOC_NAME; do
            [[ -n "${LONG_ADHOC_NAME}" ]] || continue
            
            EXPORTED_NAME="${LONG_ADHOC_NAME:21}"
            echo " --> Decrypting ad-hoc secret ${EXPORTED_NAME}"

            # Use more memory-efficient temporary file handling
            local TEMP_KEYFILE
            TEMP_KEYFILE=$(safe_mktemp) || die "Failed to create temporary file"
            local OLD_TRAP
            OLD_TRAP="$(trap -p EXIT)"
            trap 'rm -f "${TEMP_KEYFILE}"' EXIT

            # Process the secret in chunks to reduce memory usage
            local secret_value="${!LONG_ADHOC_NAME}"
            local key_part="${secret_value%%;*}"
            local data_part="${secret_value#*;}"
            
            # Clear the original variable to free memory
            unset secret_value

            # Decrypt the AES key (stream processing to reduce memory)
            if ! echo "${key_part}" | base64dec | openssl pkeyutl -decrypt -inkey "${AGENT_PRIVATE_KEY_PATH}" > "${TEMP_KEYFILE}"; then
                secure_delete "${TEMP_KEYFILE}"
                eval "${OLD_TRAP}"
                die "Failed to decrypt AES key for secret '${EXPORTED_NAME}'"
            fi
            
            # Clear intermediate variables
            unset key_part

            # Verify AES key length
            local keyfile_size
            keyfile_size=$(wc -c < "${TEMP_KEYFILE}" 2>/dev/null || echo "0")
            if [[ "${keyfile_size}" != "128" ]]; then
                secure_delete "${TEMP_KEYFILE}"
                eval "${OLD_TRAP}"
                die "Invalid AES key embedded in ad-hoc secret '${EXPORTED_NAME}', counted '${keyfile_size}' bytes instead of 128!"
            fi
            unset keyfile_size

            # Decrypt the actual secret data (stream processing)
            local decrypted_data
            if ! decrypted_data="$(echo "${data_part}" | base64dec | openssl enc -d -aes-256-cbc -pbkdf2 -iter 100000 -pass "file:${TEMP_KEYFILE}")"; then
                secure_delete "${TEMP_KEYFILE}"
                eval "${OLD_TRAP}"
                unset data_part
                die "Failed to decrypt secret data for '${EXPORTED_NAME}'"
            fi
            
            # Clear intermediate data and export the result
            unset data_part
            export "${EXPORTED_NAME}"="${decrypted_data}"
            unset decrypted_data

            # Clean up our keyfile and restore trap
            secure_delete "${TEMP_KEYFILE}"
            eval "${OLD_TRAP}"
            
        done <<< "${adhoc_vars}"
    fi
    
    # Clear the adhoc vars list
    unset adhoc_vars
}

# Now that we have our keys and our buildkite token, we decide whether the keys should be exported into
# the environment or not.  We only do this if one of two conditions are met:
#
#  - If we are the first job to run in this build, we are automatically authorized, as the first job is defined
#    within the WebUI, so it is assumed secure from drive-by pull requests.
#  - If we have an environment variable (`BUILDKITE_PLUGIN_CRYPTIC_BASE64_SIGNED_JOB_ID_SECRET`) and it correctly
#    verifies as a signature on the initial job ID, we consider ourselves a launched child pipeline

if [[ "${BUILDKITE_JOB_ID}" == "${BUILDKITE_INITIAL_JOB_ID}" ]]; then
    set_cryptic_privileged
elif [[ -v "BUILDKITE_PLUGIN_CRYPTIC_BASE64_SIGNED_JOB_ID_SECRET" ]]; then
    # Decode the base64-encoded signature and verify it efficiently
    SIGNATURE_FILE="$(safe_mktemp)" || die "Failed to create signature temp file"
    OLD_TRAP="$(trap -p EXIT)"
    trap 'rm -f "${SIGNATURE_FILE}"' EXIT
    
    # Stream decode directly to file to avoid keeping data in memory
    if ! echo "${BUILDKITE_PLUGIN_CRYPTIC_BASE64_SIGNED_JOB_ID_SECRET}" | openssl base64 -d -A > "${SIGNATURE_FILE}"; then
        rm -f "${SIGNATURE_FILE}"
        eval "${OLD_TRAP}"
        die "Failed to decode signature data"
    fi

    # Verify that the signature is valid using streaming verification
    verification_result=false
    if echo "${BUILDKITE_INITIAL_JOB_ID}" | openssl dgst -sha256 -verify "${AGENT_PUBLIC_KEY_PATH}" -signature "${SIGNATURE_FILE}" >/dev/null 2>&1; then
        verification_result=true
    fi

    # Clean up signature file immediately
    rm -f "${SIGNATURE_FILE}"
    eval "${OLD_TRAP}"
    
    # Only set privileged mode if verification succeeded
    if [[ "${verification_result}" == "true" ]]; then
        set_cryptic_privileged
    fi
    
    unset verification_result SIGNATURE_FILE OLD_TRAP
fi
