#!/bin/bash

## post-command hook: This hook implements treehash verification and pipeline launching

# Load common tools
CRYPTIC_REPO="$( cd "$( dirname "$( dirname "${BASH_SOURCE[0]}" )" )" &> /dev/null && pwd )"
source "${CRYPTIC_REPO}/lib/common.sh"

# If we're not authorized, quit out immediately
if [[ "${BUILDKITE_PLUGIN_CRYPTIC_PRIVILEGED:-false}" != "true" ]]; then
    echo "Exiting immediately, as we're not privileged"
    exit 0
fi

# If the command hook failed, quit out immediately
if [[ "$BUILDKITE_COMMAND_EXIT_STATUS" != "0" ]]; then
    echo "Exiting immediately, as the command block reported an error"
    exit 0
fi

# Extract the public key
PUBLIC_KEY_PATH=$(mktemp)
base64dec <<<"${BUILDKITE_PLUGIN_CRYPTIC_BASE64_AGENT_PUBLIC_KEY_SECRET}" >"${PUBLIC_KEY_PATH}"
if ! is_rsa_public_key "${PUBLIC_KEY_PATH}"; then
    die "Invalid RSA private key passed from agent environment hook!"
fi

# Collect all the signed and unsigned pipeline configurations we have
readarray -d '' -t UNSIGNED_PIPELINES < <(collect_buildkite_array "BUILDKITE_PLUGIN_CRYPTIC_UNSIGNED_PIPELINES" "PIPELINE")
readarray -d '' -t SIGNED_PIPELINES < <(collect_buildkite_array "BUILDKITE_PLUGIN_CRYPTIC_SIGNED_PIPELINES" "PIPELINE")

# Immediately launch all the unsigned pipelines
for PIPELINE_PATH in "${UNSIGNED_PIPELINES[@]}"; do
    buildkite-agent pipeline upload "${PIPELINE_PATH}"
done

SHOULD_FAIL=false
for PIPELINE_IDX in "${!SIGNED_PIPELINES[@]}"; do
    PIPELINE_PATH="${SIGNED_PIPELINES[${PIPELINE_IDX}]}"

    # Hash up the inputs
    readarray -d '' -t PIPELINE_INPUTS < <(collect_buildkite_array "BUILDKITE_PLUGIN_CRYPTIC_SIGNED_PIPELINES_${PIPELINE_IDX}_INPUTS")
    INPUT_TREEHASHES=( "$(calc_treehash <<<"${PIPELINE_PATH}")" )
    for PATTERN in "${PIPELINE_INPUTS[@]}"; do
        INPUT_TREEHASHES+=( "$(collect_glob_pattern "${PATTERN}" | calc_treehash)" )
    done

    # Hash all treehashes together to get full input hash
    FULL_TREEHASH="$(printf "%s" "${INPUT_TREEHASHES[@]}" | calc_shasum)"

    # Verify this with the treehash signature
    SIGNATURE_VAR="BUILDKITE_PLUGIN_CRYPTIC_SIGNED_PIPELINES_${PIPELINE_IDX}_SIGNATURE"
    SIGNATURE_FILE_VAR="BUILDKITE_PLUGIN_CRYPTIC_SIGNED_PIPELINES_${PIPELINE_IDX}_SIGNATURE_FILE"

    # Die if we don't have any signatures
    if [[ ! -v "${SIGNATURE_VAR}" ]] && [[ ! -v "${SIGNATURE_FILE_VAR}" ]]; then
        # Execute `die` in a subshell so that we can print out failure messages for each pipeline,
        # then fail out once at the end, ignoring the `exit` and failure that it creates.
        (die "Locked pipeline '${PIPELINE_PATH}' must define either 'signature' or 'siganture_file'"; ) || true
        SHOULD_FAIL=true
        continue
    fi

    # If both are provided, just use the signature_file
    if [[ -v "${SIGNATURE_FILE_VAR}" ]]; then
        SIGNATURE_FILE="${!SIGNATURE_FILE_VAR}"
    else
        SIGNATURE_FILE=$(mktemp)
        base64dec <<<"${!SIGNATURE_VAR}" >"${SIGNATURE_FILE}"
    fi
    if ! echo "${FULL_TREEHASH}" | check_rsa_signature "${PUBLIC_KEY_PATH}" "${SIGNATURE_FILE}"; then
        # Execute `die` in a subshell so that we can print out failure messages for each pipeline,
        # then fail out once at the end, ignoring the `exit` and failure that it creates.
        (die "Refusing to continue execution; pipeline '${PIPELINE_PATH}' fails treehash signature check!  You may need to re-run cryptic/bin/sign_treehashes!"; ) || true
        SHOULD_FAIL=true
        continue
    fi

    # If we passed, launch the pipeline!
    echo " -> Launching ${PIPELINE_PATH}"
    buildkite-agent pipeline upload "${PIPELINE_PATH}"
done

# Clean up the value
unset BUILDKITE_PLUGIN_CRYPTIC_BASE64_SIGNED_JOB_ID_SECRET

# This is used to allow us to fail at the end, after trying all pipelines
if [[ "${SHOULD_FAIL}" != "false" ]]; then
    exit 1
fi
