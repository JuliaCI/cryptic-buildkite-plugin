#!/bin/bash

## post-command hook: This hook implements treehash verification and pipeline launching

# Load common tools
CRYPTIC_REPO="$( cd "$( dirname "$( dirname "${BASH_SOURCE[0]}" )" )" &> /dev/null && pwd )"
source "${CRYPTIC_REPO}/lib/common.sh"

# If we're not authorized, quit out immediately
if [[ "${BUILDKITE_PLUGIN_CRYPTIC_PRIVILEGED:-false}" != "true" ]]; then
    echo "Exiting immediately, as we're not privileged"
    exit 0
fi

# If the command hook failed, quit out immediately
if [[ "$BUILDKITE_COMMAND_EXIT_STATUS" != "0" ]]; then
    echo "Exiting immediately, as the command block reported an error"
    exit 0
fi

# Extract the public key
PUBLIC_KEY_PATH=$(mktemp)
base64dec <<<"${BUILDKITE_PLUGIN_CRYPTIC_BASE64_AGENT_PUBLIC_KEY_SECRET}" >"${PUBLIC_KEY_PATH}"
if ! is_rsa_private_key "${PRIVATE_KEY_PATH}"; then
    die "Invalid RSA private key passed from agent environment hook!"
fi

# Collect all the locked pipeline configurations we have
readarray -d '' -t LOCKED_PIPELINES < <(collect_buildkite_array "BUILDKITE_PLUGIN_CRYPTIC_LOCKED_PIPELINES" "PIPELINE")

# Generate signed token for use in triggering future pipelines
export BUILDKITE_PLUGIN_CRYPTIC_BASE64_SIGNED_JOB_ID_SECRET="$(sign_rsa "${PRIVATE_KEY_PATH}" <<<"${BUILDKITE_INITIAL_JOB_ID}" | base64enc)"

SHOULD_FAIL=false
for PIPELINE_IDX in "${!LOCKED_PIPELINES[@]}"; do
    PIPELINE_PATH="${LOCKED_PIPELINES[${PIPELINE_IDX}]}"

    # Hash up the inputs
    readarray -d '' -t PIPELINE_INPUTS < <(collect_buildkite_array "BUILDKITE_PLUGIN_CRYPTIC_LOCKED_PIPELINES_${PIPELINE_IDX}_INPUTS")
    INPUT_TREEHASHES=( "$(calc_treehash <<<"${PIPELINE_PATH}")" )
    for PATTERN in "${PIPELINE_INPUTS[@]}"; do
        INPUT_TREEHASHES+=( "$(collect_glob_pattern "${PATTERN}" | calc_treehash)" )
    done

    # Hash all treehashes together to get full input hash
    FULL_TREEHASH="$(printf "%s" "${INPUT_TREEHASHES[@]}" | calc_shasum)"

    # Compare this with the known-good treehash
    SIGNATURE_VAR="BUILDKITE_PLUGIN_CRYPTIC_LOCKED_PIPELINES_${PIPELINE_IDX}_SIGNATURE"
    SIGNATURE_FILE=$(mktemp)
    base64dec <<<"${!SIGNATURE_VAR}" >"${SIGNATURE_FILE}"
    if ! echo "${FULL_TREEHASH}" | check_rsa_signature "${PUBLIC_KEY_PATH}" "${SIGNATURE_FILE}"; then
        # Execute `die` in a subshell so that we can print out failure messages for each pipeline,
        # then fail out once at the end, ignoring the `exit` and failure that it creates.
        (die "Refusing to continue execution; pipeline '${PIPELINE_PATH}' fails treehash signature check!  You may need to re-run cryptic/bin/sign_treehashes!"; ) || true
        SHOULD_FAIL="true"
    else
        # If we passed, launch the pipeline!
        echo " -> Launching ${PIPELINE_PATH}"
        buildkite-agent pipeline upload "${PIPELINE_PATH}"
    fi
done

unset BUILDKITE_PLUGIN_CRYPTIC_BASE64_SIGNED_JOB_ID_SECRET

# This is used to allow us to fail at the end, after trying all pipelines
if [[ "${SHOULD_FAIL}" != "false" ]]; then
    exit 1
fi
